<?xml version="1.0" ?>
<testsuites name="codescoring">	
    <testsuite tests= "31" failures="31" errors="0" skipped="0" time="" name= "/home/dude/GolandProjects/johnny-depp/fixtures/manifests/python/poetry.lock">
		
        <testcase classname="pkg:pypi/django@3.0.7" name="[7.5 High] [9.8 Critical] CVE-2021-35042"  time="">
            <failure type="description">Django 3.1.x before 3.1.13 and 3.2.x before 3.2.5 allows QuerySet.order_by SQL injection if order_by is untrusted input from a client of a web application.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[7.5 High] [9.8 Critical] CVE-2022-28346"  time="">
            <failure type="description">An issue was discovered in Django 2.2 before 2.2.28, 3.2 before 3.2.13, and 4.0 before 4.0.4. QuerySet.annotate(), aggregate(), and extra() methods are subject to SQL injection in column aliases via a crafted dictionary (with dictionary expansion) as the passed **kwargs.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[7.5 High] [9.8 Critical] CVE-2022-28347"  time="">
            <failure type="description">A SQL injection issue was discovered in QuerySet.explain() in Django 2.2 before 2.2.28, 3.2 before 3.2.13, and 4.0 before 4.0.4. This occurs by passing a crafted dictionary (with dictionary expansion) as the **options argument, and placing the injection payload in an option name.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[7.5 High] [9.8 Critical] CVE-2022-34265"  time="">
            <failure type="description">An issue was discovered in Django 3.2 before 3.2.14 and 4.0 before 4.0.6. The Trunc() and Extract() database functions are subject to SQL injection if untrusted data is used as a kind/lookup_name value. Applications that constrain the lookup name and kind choice to a known safe list are unaffected.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[None] [9.8 Critical] CVE-2023-31047"  time="">
            <failure type="description">In Django 3.2 before 3.2.19, 4.x before 4.1.9, and 4.2 before 4.2.1, it was possible to bypass validation when using one form field to upload multiple files. This multiple upload has never been supported by forms.FileField or forms.ImageField (only the last uploaded file was validated). However, Django&#39;s &#34;Uploading multiple files&#34; documentation suggested otherwise.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[None] [8.8 High] CVE-2022-36359"  time="">
            <failure type="description">An issue was discovered in the HTTP FileResponse class in Django 3.2 before 3.2.15 and 4.0 before 4.0.7. An application is vulnerable to a reflected file download (RFD) attack that sets the Content-Disposition header of a FileResponse when the filename is derived from user-supplied input.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[5.0 Medium] [7.5 High] CVE-2021-45115"  time="">
            <failure type="description">An issue was discovered in Django 2.2 before 2.2.26, 3.2 before 3.2.11, and 4.0 before 4.0.1. UserAttributeSimilarityValidator incurred significant overhead in evaluating a submitted password that was artificially large in relation to the comparison values. In a situation where access to user registration was unrestricted, this provided a potential vector for a denial-of-service attack.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[5.0 Medium] [7.5 High] CVE-2021-45116"  time="">
            <failure type="description">An issue was discovered in Django 2.2 before 2.2.26, 3.2 before 3.2.11, and 4.0 before 4.0.1. Due to leveraging the Django Template Language&#39;s variable resolution logic, the dictsort template filter was potentially vulnerable to information disclosure, or an unintended method call, if passed a suitably crafted key.</failure>
        </testcase>
        <testcase classname="pkg:pypi/py@1.9" name="[5.0 Medium] [7.5 High] CVE-2020-29651"  time="">
            <failure type="description">A denial of service via regular expression in the py.path.svnwc component of py (aka python-py) through 1.9.0 could be used by attackers to cause a compute-time denial of service attack by supplying malicious input to the blame functionality.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[5.0 Medium] [7.5 High] CVE-2020-24583"  time="">
            <failure type="description">An issue was discovered in Django 2.2 before 2.2.16, 3.0 before 3.0.10, and 3.1 before 3.1.1 (when Python 3.7+ is used). FILE_UPLOAD_DIRECTORY_PERMISSIONS mode was not applied to intermediate-level directories created in the process of uploading files. It was also not applied to intermediate-level collected static directories when using the collectstatic management command.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[5.0 Medium] [7.5 High] CVE-2022-23833"  time="">
            <failure type="description">An issue was discovered in MultiPartParser in Django 2.2 before 2.2.27, 3.2 before 3.2.12, and 4.0 before 4.0.2. Passing certain inputs to multipart forms could result in an infinite loop when parsing files.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[5.0 Medium] [7.5 High] CVE-2020-24584"  time="">
            <failure type="description">An issue was discovered in Django 2.2 before 2.2.16, 3.0 before 3.0.10, and 3.1 before 3.1.1 (when Python 3.7+ is used). The intermediate-level directories of the filesystem cache had the system&#39;s standard umask rather than 0o077.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[5.0 Medium] [7.5 High] CVE-2021-33571"  time="">
            <failure type="description">In Django 2.2 before 2.2.24, 3.x before 3.1.12, and 3.2 before 3.2.4, URLValidator, validate_ipv4_address, and validate_ipv46_address do not prohibit leading zero characters in octal literals. This may allow a bypass of access control that is based on IP addresses. (validate_ipv4_address and validate_ipv46_address are unaffected with Python 3.9.5+..) .</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[5.0 Medium] [7.5 High] CVE-2021-31542"  time="">
            <failure type="description">In Django 2.2 before 2.2.21, 3.1 before 3.1.9, and 3.2 before 3.2.1, MultiPartParser, UploadedFile, and FieldFile allowed directory traversal via uploaded files with suitably crafted file names.</failure>
        </testcase>
        <testcase classname="pkg:pypi/sqlparse@0.3.1" name="[5.0 None] [7.5 High] CVE-2023-30608"  time="">
            <failure type="description">sqlparse is a non-validating SQL parser module for Python. In affected versions the SQL parser contains a regular expression that is vulnerable to ReDoS (Regular Expression Denial of Service). This issue was introduced by commit `e75e358`. The vulnerability may lead to Denial of Service (DoS). This issues has been fixed in sqlparse 0.4.4 by commit `c457abd5f`. Users are advised to upgrade. There are no known workarounds for this issue.&#xA;</failure>
        </testcase>
        <testcase classname="pkg:pypi/py@1.9" name="[5.0 None] [7.5 High] CVE-2022-42969"  time="">
            <failure type="description">The py library through 1.11.0 for Python allows remote attackers to conduct a ReDoS (Regular expression Denial of Service) attack via a Subversion repository with crafted info data, because the InfoSvnCommand argument is mishandled.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[None] [7.5 High] CVE-2022-41323"  time="">
            <failure type="description">In Django 3.2 before 3.2.16, 4.0 before 4.0.8, and 4.1 before 4.1.2, internationalized URLs were subject to a potential denial of service attack via the locale parameter, which is treated as a regular expression.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[None] [7.5 High] CVE-2023-23969"  time="">
            <failure type="description">In Django 3.2 before 3.2.17, 4.0 before 4.0.9, and 4.1 before 4.1.6, the parsed values of Accept-Language headers are cached in order to avoid repetitive parsing. This leads to a potential denial-of-service vector via excessive memory usage if the raw value of Accept-Language headers is very large.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[None] [7.5 High] CVE-2023-24580"  time="">
            <failure type="description">An issue was discovered in the Multipart Request Parser in Django 3.2 before 3.2.18, 4.0 before 4.0.10, and 4.1 before 4.1.7. Passing certain inputs (e.g., an excessive number of parts) to multipart forms could result in too many open files or memory exhaustion, and provided a potential vector for a denial-of-service attack.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[None] [7.5 High] CVE-2023-36053"  time="">
            <failure type="description">In Django 3.2 before 3.2.20, 4 before 4.1.10, and 4.2 before 4.2.3, EmailValidator and URLValidator are subject to a potential ReDoS (regular expression denial of service) attack via a very large number of domain name labels of emails and URLs.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[None] [7.5 High] CVE-2023-41164"  time="">
            <failure type="description">In Django 3.2 before 3.2.21, 4.1 before 4.1.11, and 4.2 before 4.2.5, django.utils.encoding.uri_to_iri() is subject to a potential DoS (denial of service) attack via certain inputs with a very large number of Unicode characters.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[None] [7.5 High] CVE-2023-43665"  time="">
            <failure type="description">In Django 3.2 before 3.2.22, 4.1 before 4.1.12, and 4.2 before 4.2.6, the django.utils.text.Truncator chars() and words() methods (when used with html=True) are subject to a potential DoS (denial of service) attack via certain inputs with very long, potentially malformed HTML text. The chars() and words() methods are used to implement the truncatechars_html and truncatewords_html template filters, which are thus also vulnerable. NOTE: this issue exists because of an incomplete fix for CVE-2019-14232.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[None] [7.5 High] CVE-2023-46695"  time="">
            <failure type="description">An issue was discovered in Django 3.2 before 3.2.23, 4.1 before 4.1.13, and 4.2 before 4.2.7. The NFKC normalization is slow on Windows. As a consequence, django.contrib.auth.forms.UsernameField is subject to a potential DoS (denial of service) attack via certain inputs with a very large number of Unicode characters.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[7.5 High] [7.3 High] CVE-2021-44420"  time="">
            <failure type="description">In Django 2.2 before 2.2.25, 3.1 before 3.1.14, and 3.2 before 3.2.10, HTTP requests for URLs with trailing newlines could bypass upstream access control based on URL paths.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[4.3 Medium] [6.1 Medium] CVE-2021-32052"  time="">
            <failure type="description">In Django 2.2 before 2.2.22, 3.1 before 3.1.10, and 3.2 before 3.2.2 (with Python 3.9.5+), URLValidator does not prohibit newlines and tabs (unless the URLField form field is used). If an application uses values with newlines in an HTTP response, header injection can occur. Django itself is unaffected because HttpResponse prohibits newlines in HTTP headers.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[4.3 Medium] [6.1 Medium] CVE-2022-22818"  time="">
            <failure type="description">The {% debug %} template tag in Django 2.2 before 2.2.27, 3.2 before 3.2.12, and 4.0 before 4.0.2 does not properly encode the current context. This may lead to XSS.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[5.0 Medium] [5.3 Medium] CVE-2021-45452"  time="">
            <failure type="description">Storage.save in Django 2.2 before 2.2.26, 3.2 before 3.2.11, and 4.0 before 4.0.1 allows directory traversal if crafted filenames are directly passed to it.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[5.0 Medium] [5.3 Medium] CVE-2021-3281"  time="">
            <failure type="description">In Django 2.2 before 2.2.18, 3.0 before 3.0.12, and 3.1 before 3.1.6, the django.utils.archive.extract method (used by &#34;startapp --template&#34; and &#34;startproject --template&#34;) allows directory traversal via an archive with absolute paths or relative paths with dot segments.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[5.0 Medium] [5.3 Medium] CVE-2021-28658"  time="">
            <failure type="description">In Django 2.2 before 2.2.20, 3.0 before 3.0.14, and 3.1 before 3.1.8, MultiPartParser allowed directory traversal via uploaded files with suitably crafted file names. Built-in upload handlers were not affected by this vulnerability.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[4.0 Medium] [4.9 Medium] CVE-2021-33203"  time="">
            <failure type="description">Django before 2.2.24, 3.x before 3.1.12, and 3.2.x before 3.2.4 has a potential directory traversal via django.contrib.admindocs. Staff members could use the TemplateDetailView view to check the existence of arbitrary files. Additionally, if (and only if) the default admindocs templates have been customized by application developers to also show file contents, then not only the existence but also the file contents would have been exposed. In other words, there is directory traversal outside of the template root directories.</failure>
        </testcase>
        <testcase classname="pkg:pypi/django@3.0.7" name="[None] [Medium] CVE-2024-24680"  time="">
            <failure type="description">An issue was discovered in Django 3.2 before 3.2.24, 4.2 before 4.2.10, and Django 5.0 before 5.0.2. The intcomma template filter was subject to a potential denial-of-service attack when used with very long strings.</failure>
        </testcase>
    </testsuite>
</testsuites>