<?xml version="1.0" ?>
<testsuites name="CodeScoring">	
    <testsuite tests= "55" failures="55" errors="0" skipped="0" time="" name= "ubuntu:latest">
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [9.8 Critical] CVE-2023-25139"  time="">
            <failure type="description">sprintf in the GNU C Library (glibc) 2.37 has a buffer overflow (out-of-bounds write) in some situations with a correct buffer size. This is unrelated to CWE-676. It may write beyond the bounds of the destination buffer when attempting to write a padded, thousands-separated string representation of a number, if the buffer is allocated the exact size required to represent that number as a string. For example, 1,234,567 (with padding to 13) overflows by two bytes.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [9.8 Critical] CVE-2023-25139"  time="">
            <failure type="description">sprintf in the GNU C Library (glibc) 2.37 has a buffer overflow (out-of-bounds write) in some situations with a correct buffer size. This is unrelated to CWE-676. It may write beyond the bounds of the destination buffer when attempting to write a padded, thousands-separated string representation of a number, if the buffer is allocated the exact size required to represent that number as a string. For example, 1,234,567 (with padding to 13) overflows by two bytes.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [7.8 High] CVE-2023-6246"  time="">
            <failure type="description">A heap-based buffer overflow was found in the __vsyslog_internal function of the glibc library. This function is called by the syslog and vsyslog functions. This issue occurs when the openlog function was not called, or called with the ident argument set to NULL, and the program name (the basename of argv[0]) is bigger than 1024 bytes, resulting in an application crash or local privilege escalation. This issue affects glibc 2.36 and newer.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [7.8 High] CVE-2023-6246"  time="">
            <failure type="description">A heap-based buffer overflow was found in the __vsyslog_internal function of the glibc library. This function is called by the syslog and vsyslog functions. This issue occurs when the openlog function was not called, or called with the ident argument set to NULL, and the program name (the basename of argv[0]) is bigger than 1024 bytes, resulting in an application crash or local privilege escalation. This issue affects glibc 2.36 and newer.</failure>
        </testcase>
        <testcase classname="pkg:deb/bash@5.1-6ubuntu1?distro=ubuntu-22.04" name="[None] [7.8 High] CVE-2022-3715"  time="">
            <failure type="description">A flaw was found in the bash package, where a heap-buffer overflow can occur in valid parameter_transform. This issue may lead to memory problems.</failure>
        </testcase>
        <testcase classname="pkg:deb/libpcre3@2:8.39-13ubuntu0.22.04.1?distro=ubuntu-22.04&amp;upstream=pcre3" name="[7.8 High] [7.5 High] CVE-2017-11164"  time="">
            <failure type="description">In PCRE 8.41, the OP_KETRMAX feature in the match function in pcre_exec.c allows stack exhaustion (uncontrolled recursion) when processing a crafted regular expression.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 Medium] [7.5 High] CVE-2016-20013"  time="">
            <failure type="description">sha256crypt and sha512crypt through 0.6 allow attackers to cause a denial of service (CPU consumption) because the algorithm&#39;s runtime is proportional to the square of the length of the password.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 Medium] [7.5 High] CVE-2016-20013"  time="">
            <failure type="description">sha256crypt and sha512crypt through 0.6 allow attackers to cause a denial of service (CPU consumption) because the algorithm&#39;s runtime is proportional to the square of the length of the password.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [7.5 High] CVE-2023-6779"  time="">
            <failure type="description">An off-by-one heap-based buffer overflow was found in the __vsyslog_internal function of the glibc library. This function is called by the syslog and vsyslog functions. This issue occurs when these functions are called with a message bigger than INT_MAX bytes, leading to an incorrect calculation of the buffer size to store the message, resulting in an application crash. This issue affects glibc 2.37 and newer.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [7.5 High] CVE-2023-6779"  time="">
            <failure type="description">An off-by-one heap-based buffer overflow was found in the __vsyslog_internal function of the glibc library. This function is called by the syslog and vsyslog functions. This issue occurs when these functions are called with a message bigger than INT_MAX bytes, leading to an incorrect calculation of the buffer size to store the message, resulting in an application crash. This issue affects glibc 2.37 and newer.</failure>
        </testcase>
        <testcase classname="pkg:deb/libssl3@3.0.2-0ubuntu1.15?distro=ubuntu-22.04&amp;upstream=openssl" name="[None] [7.5 High] CVE-2022-40735"  time="">
            <failure type="description">The Diffie-Hellman Key Agreement Protocol allows use of long exponents that arguably make certain calculations unnecessarily expensive, because the 1996 van Oorschot and Wiener paper found that &#34;(appropriately) short exponents&#34; can be used when there are adequate subgroup constraints, and these short exponents can lead to less expensive calculations than for long exponents. This issue is different from CVE-2002-20001 because it is based on an observation about exponent size, rather than an observation about numbers that are not public keys. The specific situations in which calculation expense would constitute a server-side vulnerability depend on the protocol (e.g., TLS, SSH, or IKE) and the DHE implementation details. In general, there might be an availability concern because of server-side resource consumption from DHE modular-exponentiation calculations. Finally, it is possible for an attacker to exploit this vulnerability and CVE-2002-20001 together.</failure>
        </testcase>
        <testcase classname="pkg:deb/libzstd1@1.4.8%2Bdfsg-3build1?distro=ubuntu-22.04&amp;upstream=libzstd" name="[None] [7.5 High] CVE-2022-4899"  time="">
            <failure type="description">A vulnerability was found in zstd v1.4.10, where an attacker can supply empty string as an argument to the command line tool to cause buffer overrun.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [6.5 Medium] CVE-2023-4527"  time="">
            <failure type="description">A flaw was found in glibc. When the getaddrinfo function is called with the AF_UNSPEC address family and the system is configured with no-aaaa mode via /etc/resolv.conf, a DNS response via TCP larger than 2048 bytes can potentially disclose stack contents through the function returned address data, and may cause a crash.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [6.5 Medium] CVE-2023-4527"  time="">
            <failure type="description">A flaw was found in glibc. When the getaddrinfo function is called with the AF_UNSPEC address family and the system is configured with no-aaaa mode via /etc/resolv.conf, a DNS response via TCP larger than 2048 bytes can potentially disclose stack contents through the function returned address data, and may cause a crash.</failure>
        </testcase>
        <testcase classname="pkg:deb/coreutils@8.32-4.1ubuntu1.1?distro=ubuntu-22.04" name="[2.1 Low] [6.5 Medium] CVE-2016-2781"  time="">
            <failure type="description">chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal&#39;s input buffer.</failure>
        </testcase>
        <testcase classname="pkg:deb/libsystemd0@249.11-0ubuntu3.12?distro=ubuntu-22.04&amp;upstream=systemd" name="[5.0 None] [5.9 Medium] CVE-2023-7008"  time="">
            <failure type="description">A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.</failure>
        </testcase>
        <testcase classname="pkg:deb/libudev1@249.11-0ubuntu3.12?distro=ubuntu-22.04&amp;upstream=systemd" name="[5.0 None] [5.9 Medium] CVE-2023-7008"  time="">
            <failure type="description">A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.</failure>
        </testcase>
        <testcase classname="pkg:deb/libsystemd0@249.11-0ubuntu3.12?distro=ubuntu-22.04&amp;upstream=systemd" name="[5.0 None] [5.5 Medium] CVE-2022-45873"  time="">
            <failure type="description">systemd 250 and 251 allows local users to achieve a systemd-coredump deadlock by triggering a crash that has a long backtrace. This occurs in parse_elf_object in shared/elf-util.c. The exploitation methodology is to crash a binary calling the same function recursively, and put it in a deeply nested directory to make its backtrace large enough to cause the deadlock. This must be done 16 times when MaxConnections=16 is set for the systemd/units/systemd-coredump.socket file.</failure>
        </testcase>
        <testcase classname="pkg:deb/libudev1@249.11-0ubuntu3.12?distro=ubuntu-22.04&amp;upstream=systemd" name="[5.0 None] [5.5 Medium] CVE-2022-45873"  time="">
            <failure type="description">systemd 250 and 251 allows local users to achieve a systemd-coredump deadlock by triggering a crash that has a long backtrace. This occurs in parse_elf_object in shared/elf-util.c. The exploitation methodology is to crash a binary calling the same function recursively, and put it in a deeply nested directory to make its backtrace large enough to cause the deadlock. This must be done 16 times when MaxConnections=16 is set for the systemd/units/systemd-coredump.socket file.</failure>
        </testcase>
        <testcase classname="pkg:deb/gcc-12-base@12.3.0-1ubuntu1~22.04?distro=ubuntu-22.04&amp;upstream=gcc-12" name="[4.3 Medium] [5.5 Medium] CVE-2022-27943"  time="">
            <failure type="description">libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</failure>
        </testcase>
        <testcase classname="pkg:deb/libgcc-s1@12.3.0-1ubuntu1~22.04?distro=ubuntu-22.04&amp;upstream=gcc-12" name="[4.3 Medium] [5.5 Medium] CVE-2022-27943"  time="">
            <failure type="description">libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</failure>
        </testcase>
        <testcase classname="pkg:deb/libstdc%2B%2B6@12.3.0-1ubuntu1~22.04?distro=ubuntu-22.04&amp;upstream=gcc-12" name="[4.3 Medium] [5.5 Medium] CVE-2022-27943"  time="">
            <failure type="description">libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</failure>
        </testcase>
        <testcase classname="pkg:deb/liblzma5@5.2.5-2ubuntu1?distro=ubuntu-22.04&amp;upstream=xz-utils" name="[None] [5.5 Medium] CVE-2020-22916"  time="">
            <failure type="description">An issue discovered in XZ 5.2.5 allows attackers to cause a denial of service via decompression of a crafted file. NOTE: the vendor disputes the claims of &#34;endless output&#34; and &#34;denial of service&#34; because decompression of the 17,486 bytes always results in 114,881,179 bytes, which is often a reasonable size increase.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [5.3 Medium] CVE-2023-6780"  time="">
            <failure type="description">An integer overflow was found in the __vsyslog_internal function of the glibc library. This function is called by the syslog and vsyslog functions. This issue occurs when these functions are called with a very long message, leading to an incorrect calculation of the buffer size to store the message, resulting in undefined behavior. This issue affects glibc 2.37 and newer.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [5.3 Medium] CVE-2023-6780"  time="">
            <failure type="description">An integer overflow was found in the __vsyslog_internal function of the glibc library. This function is called by the syslog and vsyslog functions. This issue occurs when these functions are called with a very long message, leading to an incorrect calculation of the buffer size to store the message, resulting in undefined behavior. This issue affects glibc 2.37 and newer.</failure>
        </testcase>
        <testcase classname="pkg:deb/libsystemd0@249.11-0ubuntu3.12?distro=ubuntu-22.04&amp;upstream=systemd" name="[None] [5.3 Medium] CVE-2023-31437"  time="">
            <failure type="description">An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent &#34;a reply denying that any of the finding was a security vulnerability.&#34;</failure>
        </testcase>
        <testcase classname="pkg:deb/libudev1@249.11-0ubuntu3.12?distro=ubuntu-22.04&amp;upstream=systemd" name="[None] [5.3 Medium] CVE-2023-31437"  time="">
            <failure type="description">An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent &#34;a reply denying that any of the finding was a security vulnerability.&#34;</failure>
        </testcase>
        <testcase classname="pkg:deb/libsystemd0@249.11-0ubuntu3.12?distro=ubuntu-22.04&amp;upstream=systemd" name="[None] [5.3 Medium] CVE-2023-31438"  time="">
            <failure type="description">An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent &#34;a reply denying that any of the finding was a security vulnerability.&#34;</failure>
        </testcase>
        <testcase classname="pkg:deb/libudev1@249.11-0ubuntu3.12?distro=ubuntu-22.04&amp;upstream=systemd" name="[None] [5.3 Medium] CVE-2023-31438"  time="">
            <failure type="description">An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent &#34;a reply denying that any of the finding was a security vulnerability.&#34;</failure>
        </testcase>
        <testcase classname="pkg:deb/libsystemd0@249.11-0ubuntu3.12?distro=ubuntu-22.04&amp;upstream=systemd" name="[None] [5.3 Medium] CVE-2023-31439"  time="">
            <failure type="description">An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent &#34;a reply denying that any of the finding was a security vulnerability.&#34;</failure>
        </testcase>
        <testcase classname="pkg:deb/libudev1@249.11-0ubuntu3.12?distro=ubuntu-22.04&amp;upstream=systemd" name="[None] [5.3 Medium] CVE-2023-31439"  time="">
            <failure type="description">An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent &#34;a reply denying that any of the finding was a security vulnerability.&#34;</failure>
        </testcase>
        <testcase classname="pkg:deb/gcc-12-base@12.3.0-1ubuntu1~22.04?distro=ubuntu-22.04&amp;upstream=gcc-12" name="[5.0 None] [4.8 Medium] CVE-2023-4039"  time="">
            <failure type="description">&#xA;&#xA;A failure in the -fstack-protector feature in GCC-based toolchains &#xA;that target AArch64 allows an attacker to exploit an existing buffer &#xA;overflow in dynamically-sized local variables in your application &#xA;without this being detected. This stack-protector failure only applies &#xA;to C99-style dynamically-sized local variables or those created using &#xA;alloca(). The stack-protector operates as intended for statically-sized &#xA;local variables.&#xA;&#xA;The default behavior when the stack-protector &#xA;detects an overflow is to terminate your application, resulting in &#xA;controlled loss of availability. An attacker who can exploit a buffer &#xA;overflow without triggering the stack-protector might be able to change &#xA;program flow control to cause an uncontrolled loss of availability or to&#xA; go further and affect confidentiality or integrity.&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libgcc-s1@12.3.0-1ubuntu1~22.04?distro=ubuntu-22.04&amp;upstream=gcc-12" name="[5.0 None] [4.8 Medium] CVE-2023-4039"  time="">
            <failure type="description">&#xA;&#xA;A failure in the -fstack-protector feature in GCC-based toolchains &#xA;that target AArch64 allows an attacker to exploit an existing buffer &#xA;overflow in dynamically-sized local variables in your application &#xA;without this being detected. This stack-protector failure only applies &#xA;to C99-style dynamically-sized local variables or those created using &#xA;alloca(). The stack-protector operates as intended for statically-sized &#xA;local variables.&#xA;&#xA;The default behavior when the stack-protector &#xA;detects an overflow is to terminate your application, resulting in &#xA;controlled loss of availability. An attacker who can exploit a buffer &#xA;overflow without triggering the stack-protector might be able to change &#xA;program flow control to cause an uncontrolled loss of availability or to&#xA; go further and affect confidentiality or integrity.&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libstdc%2B%2B6@12.3.0-1ubuntu1~22.04?distro=ubuntu-22.04&amp;upstream=gcc-12" name="[5.0 None] [4.8 Medium] CVE-2023-4039"  time="">
            <failure type="description">&#xA;&#xA;A failure in the -fstack-protector feature in GCC-based toolchains &#xA;that target AArch64 allows an attacker to exploit an existing buffer &#xA;overflow in dynamically-sized local variables in your application &#xA;without this being detected. This stack-protector failure only applies &#xA;to C99-style dynamically-sized local variables or those created using &#xA;alloca(). The stack-protector operates as intended for statically-sized &#xA;local variables.&#xA;&#xA;The default behavior when the stack-protector &#xA;detects an overflow is to terminate your application, resulting in &#xA;controlled loss of availability. An attacker who can exploit a buffer &#xA;overflow without triggering the stack-protector might be able to change &#xA;program flow control to cause an uncontrolled loss of availability or to&#xA; go further and affect confidentiality or integrity.&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/gpgv@2.2.27-3ubuntu2.1?distro=ubuntu-22.04&amp;upstream=gnupg2" name="[None] [3.3 Low] CVE-2022-3219"  time="">
            <failure type="description">GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</failure>
        </testcase>
        <testcase classname="pkg:deb/login@1:4.8.1-2ubuntu2.2?distro=ubuntu-22.04&amp;upstream=shadow" name="[None] [3.3 Low] CVE-2023-29383"  time="">
            <failure type="description">In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that &#34;cat /etc/passwd&#34; shows a rogue user account.</failure>
        </testcase>
        <testcase classname="pkg:deb/passwd@1:4.8.1-2ubuntu2.2?distro=ubuntu-22.04&amp;upstream=shadow" name="[None] [3.3 Low] CVE-2023-29383"  time="">
            <failure type="description">In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that &#34;cat /etc/passwd&#34; shows a rogue user account.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [Medium] CVE-2024-2961"  time="">
            <failure type="description">The iconv() function in the GNU C Library versions 2.39 and older may overflow the output buffer passed to it by up to 4 bytes when converting strings to the ISO-2022-CN-EXT character set, which may be used to crash an application or overwrite a neighbouring variable.&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[5.0 None] [Medium] CVE-2024-2961"  time="">
            <failure type="description">The iconv() function in the GNU C Library versions 2.39 and older may overflow the output buffer passed to it by up to 4 bytes when converting strings to the ISO-2022-CN-EXT character set, which may be used to crash an application or overwrite a neighbouring variable.&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libsmartcols1@2.37.2-4ubuntu3?distro=ubuntu-22.04&amp;upstream=util-linux" name="[5.0 None] [Medium] CVE-2024-28085"  time="">
            <failure type="description">wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users&#39; terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.</failure>
        </testcase>
        <testcase classname="pkg:deb/libgnutls30@3.7.3-4ubuntu1.4?distro=ubuntu-22.04&amp;upstream=gnutls28" name="[5.0 None] [Medium] CVE-2024-28834"  time="">
            <failure type="description">A flaw was found in GnuTLS. The Minerva attack is a cryptographic vulnerability that exploits deterministic behavior in systems like GnuTLS, leading to side-channel leaks. In specific scenarios, such as when using the GNUTLS_PRIVKEY_FLAG_REPRODUCIBLE flag, it can result in a noticeable step in nonce size from 513 to 512 bits, exposing a potential timing side-channel.</failure>
        </testcase>
        <testcase classname="pkg:deb/libgnutls30@3.7.3-4ubuntu1.4?distro=ubuntu-22.04&amp;upstream=gnutls28" name="[5.0 None] [Medium] CVE-2024-28835"  time="">
            <failure type="description">A flaw has been discovered in GnuTLS where an application crash can be induced when attempting to verify a specially crafted .pem bundle using the &#34;certtool --verify-chain&#34; command.</failure>
        </testcase>
        <testcase classname="pkg:deb/libssl3@3.0.2-0ubuntu1.15?distro=ubuntu-22.04&amp;upstream=openssl" name="[None] [None] CVE-2024-41996"  time="">
            <failure type="description">Validating the order of the public keys in the Diffie-Hellman Key Agreement Protocol, when an approved safe prime is used, allows remote attackers (from the client side) to trigger unnecessarily expensive server-side DHE modular-exponentiation calculations. The client may cause asymmetric resource consumption. The basic attack scenario is that the client must claim that it can only communicate with DHE, and the server must be configured to allow DHE and validate the order of the public key.</failure>
        </testcase>
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[None] [None] CVE-2024-33599"  time="">
            <failure type="description">nscd: Stack-based buffer overflow in netgroup cache&#xA;&#xA;If the Name Service Cache Daemon&#39;s (nscd) fixed size cache is exhausted&#xA;by client requests then a subsequent client request for netgroup data&#xA;may result in a stack-based buffer overflow.  This flaw was introduced&#xA;in glibc 2.15 when the cache was added to nscd.&#xA;&#xA;This vulnerability is only present in the nscd binary.&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[None] [None] CVE-2024-33599"  time="">
            <failure type="description">nscd: Stack-based buffer overflow in netgroup cache&#xA;&#xA;If the Name Service Cache Daemon&#39;s (nscd) fixed size cache is exhausted&#xA;by client requests then a subsequent client request for netgroup data&#xA;may result in a stack-based buffer overflow.  This flaw was introduced&#xA;in glibc 2.15 when the cache was added to nscd.&#xA;&#xA;This vulnerability is only present in the nscd binary.&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[None] [None] CVE-2024-33600"  time="">
            <failure type="description">nscd: Null pointer crashes after notfound response&#xA;&#xA;If the Name Service Cache Daemon&#39;s (nscd) cache fails to add a not-found&#xA;netgroup response to the cache, the client request can result in a null&#xA;pointer dereference.  This flaw was introduced in glibc 2.15 when the&#xA;cache was added to nscd.&#xA;&#xA;This vulnerability is only present in the nscd binary.&#xA;&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[None] [None] CVE-2024-33600"  time="">
            <failure type="description">nscd: Null pointer crashes after notfound response&#xA;&#xA;If the Name Service Cache Daemon&#39;s (nscd) cache fails to add a not-found&#xA;netgroup response to the cache, the client request can result in a null&#xA;pointer dereference.  This flaw was introduced in glibc 2.15 when the&#xA;cache was added to nscd.&#xA;&#xA;This vulnerability is only present in the nscd binary.&#xA;&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[None] [None] CVE-2024-33601"  time="">
            <failure type="description">nscd: netgroup cache may terminate daemon on memory allocation failure&#xA;&#xA;The Name Service Cache Daemon&#39;s (nscd) netgroup cache uses xmalloc or&#xA;xrealloc and these functions may terminate the process due to a memory&#xA;allocation failure resulting in a denial of service to the clients.  The&#xA;flaw was introduced in glibc 2.15 when the cache was added to nscd.&#xA;&#xA;This vulnerability is only present in the nscd binary.&#xA;&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[None] [None] CVE-2024-33601"  time="">
            <failure type="description">nscd: netgroup cache may terminate daemon on memory allocation failure&#xA;&#xA;The Name Service Cache Daemon&#39;s (nscd) netgroup cache uses xmalloc or&#xA;xrealloc and these functions may terminate the process due to a memory&#xA;allocation failure resulting in a denial of service to the clients.  The&#xA;flaw was introduced in glibc 2.15 when the cache was added to nscd.&#xA;&#xA;This vulnerability is only present in the nscd binary.&#xA;&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libc-bin@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[None] [None] CVE-2024-33602"  time="">
            <failure type="description">nscd: netgroup cache assumes NSS callback uses in-buffer strings&#xA;&#xA;The Name Service Cache Daemon&#39;s (nscd) netgroup cache can corrupt memory&#xA;when the NSS callback does not store all strings in the provided buffer.&#xA;The flaw was introduced in glibc 2.15 when the cache was added to nscd.&#xA;&#xA;This vulnerability is only present in the nscd binary.&#xA;&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libc6@2.35-0ubuntu3.6?distro=ubuntu-22.04&amp;upstream=glibc" name="[None] [None] CVE-2024-33602"  time="">
            <failure type="description">nscd: netgroup cache assumes NSS callback uses in-buffer strings&#xA;&#xA;The Name Service Cache Daemon&#39;s (nscd) netgroup cache can corrupt memory&#xA;when the NSS callback does not store all strings in the provided buffer.&#xA;The flaw was introduced in glibc 2.15 when the cache was added to nscd.&#xA;&#xA;This vulnerability is only present in the nscd binary.&#xA;&#xA;</failure>
        </testcase>
        <testcase classname="pkg:deb/libssl3@3.0.2-0ubuntu1.15?distro=ubuntu-22.04&amp;upstream=openssl" name="[None] [None] CVE-2024-2511"  time="">
            <failure type="description">Issue summary: Some non-default TLS server configurations can cause unbounded&#xA;memory growth when processing TLSv1.3 sessions&#xA;&#xA;Impact summary: An attacker may exploit certain server configurations to trigger&#xA;unbounded memory growth that would lead to a Denial of Service&#xA;&#xA;This problem can occur in TLSv1.3 if the non-default SSL_OP_NO_TICKET option is&#xA;being used (but not if early_data support is also configured and the default&#xA;anti-replay protection is in use). In this case, under certain conditions, the&#xA;session cache can get into an incorrect state and it will fail to flush properly&#xA;as it fills. The session cache will continue to grow in an unbounded manner. A&#xA;malicious client could deliberately create the scenario for this failure to&#xA;force a Denial of Service. It may also happen by accident in normal operation.&#xA;&#xA;This issue only affects TLS servers supporting TLSv1.3. It does not affect TLS&#xA;clients.&#xA;&#xA;The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue. OpenSSL&#xA;1.0.2 is also not affected by this issue.</failure>
        </testcase>
        <testcase classname="pkg:deb/libssl3@3.0.2-0ubuntu1.15?distro=ubuntu-22.04&amp;upstream=openssl" name="[None] [None] CVE-2024-4603"  time="">
            <failure type="description">Issue summary: Checking excessively long DSA keys or parameters may be very&#xA;slow.&#xA;&#xA;Impact summary: Applications that use the functions EVP_PKEY_param_check()&#xA;or EVP_PKEY_public_check() to check a DSA public key or DSA parameters may&#xA;experience long delays. Where the key or parameters that are being checked&#xA;have been obtained from an untrusted source this may lead to a Denial of&#xA;Service.&#xA;&#xA;The functions EVP_PKEY_param_check() or EVP_PKEY_public_check() perform&#xA;various checks on DSA parameters. Some of those computations take a long time&#xA;if the modulus (`p` parameter) is too large.&#xA;&#xA;Trying to use a very large modulus is slow and OpenSSL will not allow using&#xA;public keys with a modulus which is over 10,000 bits in length for signature&#xA;verification. However the key and parameter check functions do not limit&#xA;the modulus size when performing the checks.&#xA;&#xA;An application that calls EVP_PKEY_param_check() or EVP_PKEY_public_check()&#xA;and supplies a key or parameters obtained from an untrusted source could be&#xA;vulnerable to a Denial of Service attack.&#xA;&#xA;These functions are not called by OpenSSL itself on untrusted DSA keys so&#xA;only applications that directly call these functions may be vulnerable.&#xA;&#xA;Also vulnerable are the OpenSSL pkey and pkeyparam command line applications&#xA;when using the `-check` option.&#xA;&#xA;The OpenSSL SSL/TLS implementation is not affected by this issue.&#xA;&#xA;The OpenSSL 3.0 and 3.1 FIPS providers are affected by this issue.</failure>
        </testcase>
        <testcase classname="pkg:deb/libssl3@3.0.2-0ubuntu1.15?distro=ubuntu-22.04&amp;upstream=openssl" name="[None] [None] CVE-2024-5535"  time="">
            <failure type="description">Issue summary: Calling the OpenSSL API function SSL_select_next_proto with an&#xA;empty supported client protocols buffer may cause a crash or memory contents to&#xA;be sent to the peer.&#xA;&#xA;Impact summary: A buffer overread can have a range of potential consequences&#xA;such as unexpected application beahviour or a crash. In particular this issue&#xA;could result in up to 255 bytes of arbitrary private data from memory being sent&#xA;to the peer leading to a loss of confidentiality. However, only applications&#xA;that directly call the SSL_select_next_proto function with a 0 length list of&#xA;supported client protocols are affected by this issue. This would normally never&#xA;be a valid scenario and is typically not under attacker control but may occur by&#xA;accident in the case of a configuration or programming error in the calling&#xA;application.&#xA;&#xA;The OpenSSL API function SSL_select_next_proto is typically used by TLS&#xA;applications that support ALPN (Application Layer Protocol Negotiation) or NPN&#xA;(Next Protocol Negotiation). NPN is older, was never standardised and&#xA;is deprecated in favour of ALPN. We believe that ALPN is significantly more&#xA;widely deployed than NPN. The SSL_select_next_proto function accepts a list of&#xA;protocols from the server and a list of protocols from the client and returns&#xA;the first protocol that appears in the server list that also appears in the&#xA;client list. In the case of no overlap between the two lists it returns the&#xA;first item in the client list. In either case it will signal whether an overlap&#xA;between the two lists was found. In the case where SSL_select_next_proto is&#xA;called with a zero length client list it fails to notice this condition and&#xA;returns the memory immediately following the client list pointer (and reports&#xA;that there was no overlap in the lists).&#xA;&#xA;This function is typically called from a server side application callback for&#xA;ALPN or a client side application callback for NPN. In the case of ALPN the list&#xA;of protocols supplied by the client is guaranteed by libssl to never be zero in&#xA;length. The list of server protocols comes from the application and should never&#xA;normally be expected to be of zero length. In this case if the&#xA;SSL_select_next_proto function has been called as expected (with the list&#xA;supplied by the client passed in the client/client_len parameters), then the&#xA;application will not be vulnerable to this issue. If the application has&#xA;accidentally been configured with a zero length server list, and has&#xA;accidentally passed that zero length server list in the client/client_len&#xA;parameters, and has additionally failed to correctly handle a &#34;no overlap&#34;&#xA;response (which would normally result in a handshake failure in ALPN) then it&#xA;will be vulnerable to this problem.&#xA;&#xA;In the case of NPN, the protocol permits the client to opportunistically select&#xA;a protocol when there is no overlap. OpenSSL returns the first client protocol&#xA;in the no overlap case in support of this. The list of client protocols comes&#xA;from the application and should never normally be expected to be of zero length.&#xA;However if the SSL_select_next_proto function is accidentally called with a&#xA;client_len of 0 then an invalid memory pointer will be returned instead. If the&#xA;application uses this output as the opportunistic protocol then the loss of&#xA;confidentiality will occur.&#xA;&#xA;This issue has been assessed as Low severity because applications are most&#xA;likely to be vulnerable if they are using NPN instead of ALPN - but NPN is not&#xA;widely used. It also requires an application configuration or programming error.&#xA;Finally, this issue would not typically be under attacker control making active&#xA;exploitation unlikely.&#xA;&#xA;The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.&#xA;&#xA;Due to the low severity of this issue we are not issuing new releases of&#xA;OpenSSL at this time. The fix will be included in the next releases when they&#xA;become available.</failure>
        </testcase>
        <testcase classname="pkg:deb/libssl3@3.0.2-0ubuntu1.15?distro=ubuntu-22.04&amp;upstream=openssl" name="[None] [None] CVE-2024-6119"  time="">
            <failure type="description">Issue summary: Applications performing certificate name checks (e.g., TLS&#xA;clients checking server certificates) may attempt to read an invalid memory&#xA;address resulting in abnormal termination of the application process.&#xA;&#xA;Impact summary: Abnormal termination of an application can a cause a denial of&#xA;service.&#xA;&#xA;Applications performing certificate name checks (e.g., TLS clients checking&#xA;server certificates) may attempt to read an invalid memory address when&#xA;comparing the expected name with an `otherName` subject alternative name of an&#xA;X.509 certificate. This may result in an exception that terminates the&#xA;application program.&#xA;&#xA;Note that basic certificate chain validation (signatures, dates, ...) is not&#xA;affected, the denial of service can occur only when the application also&#xA;specifies an expected DNS name, Email address or IP address.&#xA;&#xA;TLS servers rarely solicit client certificates, and even when they do, they&#xA;generally don&#39;t perform a name check against a reference identifier (expected&#xA;identity), but rather extract the presented identity after checking the&#xA;certificate chain.  So TLS servers are generally not affected and the severity&#xA;of the issue is Moderate.&#xA;&#xA;The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.</failure>
        </testcase>
    </testsuite>
</testsuites>
